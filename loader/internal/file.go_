package internal

import (
	"crypto/md5"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

const (
	sourceDir  = "./source/"
	archiveDir = "./archive/"
)

func CreateDirectories() error {
	dirs := []string{sourceDir, archiveDir}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}
	return nil
}

type FileContainer struct {
	fileMutex     sync.Mutex
	fileFirstSeen map[string]time.Time
}

func NewFileContainer() *FileContainer {
	return &FileContainer{
		fileFirstSeen: make(map[string]time.Time),
	}
}

func WatchFile(fileChan chan<- string) {
	fmt.Printf("Start monitoring folder: %s\n", sourceDir)
	queue := NewFileContainer()

	for {
		files, err := os.ReadDir(sourceDir)
		if err != nil {
			fmt.Printf("error while reading source directory: %s\n", err)
			time.Sleep(time.Second)
			continue
		}

		currentFiles := make(map[string]bool)

		for _, file := range files {
			if !file.IsDir() {
				filePath := filepath.Join(sourceDir, file.Name())
				currentFiles[filePath] = true

				queue.fileMutex.Lock()
				if _, exists := queue.fileFirstSeen[filePath]; !exists {
					queue.fileFirstSeen[filePath] = time.Now()
					fmt.Printf("New file detected: %s\n", filePath)
				}
				queue.fileMutex.Unlock()

				//fmt.Println(queue.fileFirstSeen)

				if queue.isFileUnchanged(filePath) {
					fmt.Printf("The file %s has not been modified for more than 10 seconds. Sending...\n", filePath)
					fileChan <- filePath // Отправляем файл в канал
				} else {
					fmt.Printf("The file %s is not ready for sending yet\n", filePath)
				}
			}
		}

		// Удаляем из карты файлы, которых больше нет в директории
		queue.fileMutex.Lock()
		for filePath := range queue.fileFirstSeen {
			if !currentFiles[filePath] {
				delete(queue.fileFirstSeen, filePath)
				fmt.Printf("The file has been removed from tracking: %s\n", filePath)
			}
		}
		queue.fileMutex.Unlock()
		time.Sleep(1 * time.Second)
	}
}

func (c *FileContainer) isFileUnchanged(filePath string) bool {
	c.fileMutex.Lock()
	firstSeen, exists := c.fileFirstSeen[filePath]
	c.fileMutex.Unlock()

	if !exists {
		return false
	}

	return time.Since(firstSeen) > 10*time.Second
}

func ProcessFile(fileChan <-chan string) {
	for filePath := range fileChan {
		err := fetchFile(filePath)
		if err != nil {
			fmt.Println(err)
		}
	}
}

func fetchFile(filePath string) error {
	// Проверка существования файла перед его открытием
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		return fmt.Errorf("file does not exist: %s", filePath)
	}

	docID := generateDocumentID(filePath)

	// file, err := os.Open(filePath)
	// if err != nil {
	// 	return fmt.Errorf("error opening the file: %v", err)
	// }
	// defer func(file *os.File) {
	// 	_ = file.Close()
	// }(file)

	// // Закрытие файла перед перемещением
	// err = file.Close()
	// if err != nil {
	// 	return fmt.Errorf("error closing file")
	// }

	// Перемещение файла в архив после успешной отправки
	moveToArchive(filePath) // Убедитесь, что moveToArchive не возвращает ошибку

	return nil
}

func shouldUpdateFile(docID string, modTime time.Time) bool {
	var dbModTime time.Time
	err := db.QueryRow("SELECT updated_at FROM confluence_pages WHERE page_id = $1", docID).Scan(&dbModTime)
	if err != nil {
		// Документ не найден в БД, значит нужно добавить
		return true
	}

	// Обновляем если файл изменился
	return modTime.After(dbModTime)
}

func generateDocumentID(filePath string) string {
	hash := md5.Sum([]byte(filePath))
	return fmt.Sprintf("pdf_%x", hash)
}

func moveToArchive(filePath string) {
	currentDate := time.Now().Format("2006-01-02")
	destDir := filepath.Join(archiveDir, currentDate)

	// Проверка и создание директории
	if _, err := os.Stat(destDir); os.IsNotExist(err) {
		if err := os.MkdirAll(destDir, 0755); err != nil {
			fmt.Printf("error creating directory: %s\n", err)
			return
		}
	}

	destPath := filepath.Join(destDir, filepath.Base(filePath))

	// Обработка конфликтов имен файлов
	counter := 1
	for {
		if _, err := os.Stat(destPath); os.IsNotExist(err) {
			break
		}
		ext := filepath.Ext(destPath)
		baseName := strings.TrimSuffix(filepath.Base(destPath), ext)
		destPath = filepath.Join(destDir, fmt.Sprintf("%s_%d%s", baseName, counter, ext))
		counter++
	}

	err := os.Rename(filePath, destPath)
	if err != nil {
		fmt.Printf("error moving file to archive: %s\n", err)
		return
	}
	fmt.Printf("File moved to archive: %s\n", destPath)

}
